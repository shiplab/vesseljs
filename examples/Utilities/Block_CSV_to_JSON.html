<!--
@EliasHasle

This script converts a CSV file with blocks from the format generated by this app: http://dbb.ucl.im/snap/dbb_clickblock_September20.html
to a format that can be copy-pasted into the vessel specification.
-->
<html>
<head></head>
<body>
<!--<script src="../libs/three.js"></script>-->
<script src="../libs/d3_v4.9.1.js"></script>
<script src="../libs/browse_files_Elias_Hasle.js"></script>

<a id="importantLink" href="#" onclick="onClick()">Click here!</a>

<script>
function onClick() {
	browseFile(".csv,.txt, text/csv, text/comma-separated-values", function(file) {
		let reader = new FileReader();
		reader.onload = function(event) {
			let res = event.target.result;
			let data = d3.csvParse(res).filter(d=>d.Name!==undefined);
			
			//Generate baseObjects library:
			function stripName(s) {
				return s.replace(/[\d\s]/g, "");
			}
			function hash(bo) {
				let bd = bo.boxDimensions;
				return stripName(bo.id) + "L" + bd.length + "B" + bd.breadth + "H" + bd.height + "fd" + bo.weightInformation.fluidDensity + "F" + bo.file3D;
			}
			let baseObjects = {};
			
			let derivedObjectsSpec = data.map(function(e) {
				//Preprocess input:
				e.xAft = parseFloat(e.xAft);
				e.xFwd = parseFloat(e.xFwd);
				e.yCentre = parseFloat(e.yCentre);
				e.ySize = parseFloat(e.ySize);
				e.zBase = parseFloat(e.zBase);
				e.zHeight = parseFloat(e.zHeight);
				e.Name = e.Name.trim();
				e.Group = e.Group.trim();
				e.Classification = e.Classification.trim();
				e.FluidDensity = parseFloat(e.FluidDensity);
				e.File = e.File ? e.File.trim() : e.File;
				
				let baseObject = {
					id: e.Name,
					affiliations: {},
					boxDimensions: {
						length: e.xFwd-e.xAft,
						breadth: e.ySize,
						height: e.zHeight
					},
					weightInformation: {
						contentDensity: e.FluidDensity || 1000,
						//Sample values:
						volumeCapacity: 0.25*Math.PI*(e.xFwd-e.xAft)*e.ySize*e.zHeight,
						lightweight: 10*(e.xFwd-e.xAft)*e.ySize*e.zHeight,
						fullnessCGMapping: {
							fullnesses: [0,0.25, 0.5, 0.75, 1],
							cgs: [[0,0,0.5*e.zHeight], [0,0,0.15*e.zHeight], [0,0,0.3*e.zHeight], [0,0,0.4*e.zHeight], [0,0,0.5*e.zHeight]]
						}
					},
					capabilities: {
						/*AreaRequired: parseFloat(e.AreaRequired),
						VolRequired: parseFloat(e.VolRequired),*/
					},
					file3D: e.File,
					baseState: {
						fullness: 0.5 //dummy value
					}
				};
				
				let h = hash(baseObject);
				if (!baseObjects[h]) {
					baseObjects[h] = baseObject;
					baseObject.id = h;
				}
				baseObject = h;
			
				/*console.log("Name: "+e.Name+", xAft: "+e.xAft+", xFwd: "+e.xFwd+", 0.5*(xAft+xFwd) = "+(0.5*(e.xAft+e.xFwd)));
				console.log("Type of xAft: " +typeof e.xAft+", Type of xFwd: " + typeof e.xFwd);*/
				return {
				    id: e.Name,
					baseObject: baseObject,
					affiliations: {
						Deck: e.Group,
						SFI: e.Classification
					},
					referenceState: {
						xCentre: 0.5*(e.xAft+e.xFwd),
						yCentre: e.yCentre,
						zBase: e.zBase
					}
				};
			});
			
			baseObjectsSpec = Object.values(baseObjects);
			
			let output = '"baseObjects": \n' + JSON.stringify(baseObjectsSpec) + ',\n\n"derivedObjects": ' + JSON.stringify(derivedObjectsSpec) + "\n";
			console.log(output);

			let link = /*document.getElementById("importantLink");*/document.createElement("a");
			link.href = "data:text/json," + encodeURI(output);
			link.download = "objects.json";
			link.target = "_blank";
			//link.innerHTML = "Now click here!";
			link.click();
		}
		reader.readAsText(file);
	
	});
}
</script>
</body>
</html>